
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>A quick refresher Â· PEP root6 workshop</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-panels/panels.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-block-align/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../../css/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="smartp.md" />
    
    
    <link rel="prev" href="intro.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../introduction.html">
            
                <a href="../introduction.html">
            
                    
                    Part 1 - Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../feat1.html">
            
                <a href="../feat1.html">
            
                    
                    Part 2 - New C++ features 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="feat2.html">
            
                <a href="feat2.html">
            
                    
                    Part 3 - Smart (and dumb) pointers
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="intro.html">
            
                <a href="intro.html">
            
                    
                    Pointers, the absolute basics
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4.2" data-path="introexer.html">
            
                <a href="introexer.html">
            
                    
                    A quick refresher
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="smartp.md">
            
                <span>
            
                    
                    Smart pointers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="exer.html">
            
                <a href="exer.html">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../parallellism.html">
            
                <a href="../parallellism.html">
            
                    
                    Part 4 - Parallellism
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../parallell/intro.html">
            
                <a href="../parallell/intro.html">
            
                    
                    Threads and processes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../parallell/example.html">
            
                <a href="../parallell/example.html">
            
                    
                    Posix multithreading
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../parallell/caveats.html">
            
                <a href="../parallell/caveats.html">
            
                    
                    What can go wrong?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../parallell/root.html">
            
                <a href="../parallell/root.html">
            
                    
                    Parallellism with ROOT
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../changes.html">
            
                <a href="../changes.html">
            
                    
                    Part 5 - Changes to user code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../vectorization.html">
            
                <a href="../vectorization.html">
            
                    
                    Part 6 - Vectorization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../declarative.html">
            
                <a href="../declarative.html">
            
                    
                    Part 7 - Declarative analysis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../python/">
            
                <a href="../python/">
            
                    
                    Part 8 - Python
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../python/running.html">
            
                <a href="../python/running.html">
            
                    
                    Running
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../python/operators.html">
            
                <a href="../python/operators.html">
            
                    
                    Objects and operators
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../python/numbers.html">
            
                <a href="../python/numbers.html">
            
                    
                    Numbers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="../python/strings.html">
            
                <a href="../python/strings.html">
            
                    
                    Strings
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="../python/lists.html">
            
                <a href="../python/lists.html">
            
                    
                    Lists and looping
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="../python/dictionaries.html">
            
                <a href="../python/dictionaries.html">
            
                    
                    Dictionaries
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.7" data-path="../python/conditions.html">
            
                <a href="../python/conditions.html">
            
                    
                    Conditions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.8" data-path="../python/methods.html">
            
                <a href="../python/methods.html">
            
                    
                    Methods
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.9" data-path="../python/scripting.html">
            
                <a href="../python/scripting.html">
            
                    
                    Scripting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.10" data-path="../python/modules.html">
            
                <a href="../python/modules.html">
            
                    
                    Modules
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.11" data-path="../python/learning.html">
            
                <a href="../python/learning.html">
            
                    
                    Learning more
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.12" data-path="../python/first_histogram.html">
            
                <a href="../python/first_histogram.html">
            
                    
                    Making your first histogram
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.13" data-path="../python/further_reading.html">
            
                <a href="../python/further_reading.html">
            
                    
                    Further reading
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../bestprac/best_prac.html">
            
                <a href="../bestprac/best_prac.html">
            
                    
                    Part 9 - Best Practices
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="../bestprac/preparing.html">
            
                <a href="../bestprac/preparing.html">
            
                    
                    Preparing your code for debugging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="../bestprac/general.html">
            
                <a href="../bestprac/general.html">
            
                    
                    Some general programming tips
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="../bestprac/crash.html">
            
                <a href="../bestprac/crash.html">
            
                    
                    Where does my code crash
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="../bestprac/memory.html">
            
                <a href="../bestprac/memory.html">
            
                    
                    Finding memory leaks
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >A quick refresher</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="welcome-to-the-exercise-part">welcome to the exercise part</h1>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(4453627242);" id="-question-"><i class="fa fa-square-o"></i>  Question <span id="heading-4453627242"></span></h3></div><div class="panel-body" id="panel-4453627242"><p>Considering only performance, when should you pass small objects by value, reference and pointer?</p>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> SmallStruct { <span class="hljs-keyword">int</span> i };

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(SmallStruct s)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(SmallStruct&amp; s)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(SmallStruct* s)</span></span>;
</code></pre>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(6776090011);" id="-solution-click-to-expand"><i class="fa fa-line-chart"></i>  Solution <span id="heading-6776090011">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-6776090011"><p>There was no significant performance difference between passing small objects (or built-ins) by value, reference, or pointer.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(2808780779);" id="-question-"><i class="fa fa-square-o"></i>  Question <span id="heading-2808780779"></span></h3></div><div class="panel-body" id="panel-2808780779"><p>Considering only performance, when should you pass large objects by value, reference and pointer?</p>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> LargeStruct { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; i };

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(LargeStruct s)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(LargeStruct&amp; s)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(LargeStruct* s)</span></span>;
{% solution <span class="hljs-string">&quot; Solution &quot;</span> %}

</code></pre>
<p>Passing by value is the slowest since Foo&apos;s copy constructor is invoked for each call. Passing by reference or by pointer essentially copy a machine word &#x2014; there&apos;s no significant difference.</p>
</div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(440876078);" id="-question-"><i class="fa fa-square-o"></i>  Question <span id="heading-440876078"></span></h3></div><div class="panel-body" id="panel-440876078"><p>Are there reasons to prefer one argument-passing mechanism to another?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(2990149883);" id="-solution-click-to-expand"><i class="fa fa-line-chart"></i>  Solution <span id="heading-2990149883">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-2990149883"><p>The difference between writing <code>-&gt;</code> versus <code>.</code> is trivial. More important to writing clear code is the semantic difference between them.  Consider the following code:</p>
<pre><code>```c++
</code></pre><p>void foo(MyLargObj* p)
{
    p-&gt;bar();
}</p>
<pre><code>Perhaps when you first wrote `foo`, it was called in one place, and you knew that `p` would always be valid.  Maybe you even wrote a comment for `foo` inidcating the precondition that `p` should never be `NULL`.  Inevitably, someone (maybe you) will pass `NULL`.  You might then feel the need to check `p` after all.
    ```c++
void foo(MyLargObj* p)
{
    if (!p)
        return;
    p-&gt;bar();
}
</code></pre><p>This can lead to other problems -- what if a post condition of <code>foo()</code> is that the postcondition of <code>MyLargObj::bar</code> hold?  Code executed later might still fail.  You might decide that throwing an exception is more appropriate.  You could get concerned about throwing an exception when checking a precondition and check on the internet for when it&apos;s appropriate.  You could be reading differing viewpoints on it for years, and if you don&apos;t immediately agree that you should <code>assert</code>, you&apos;ll probably do the wrong thing ;).</p>
<p>No matter what you choose, that choice was necessitated by the fact that pointers may assume invalid values. So, if passing in a value is truly optional, passing by pointer may be appropriate. If a precondition of the function requires no invalid values, consider pass-by-reference or pass-by-value &#x2014; this more explicitly declares the domain of a given function.  Foo becomes:</p>
<pre><code>```c++
</code></pre><p>void foo(MyLargObj&amp; p)
{
    p.bar();
}</p>
<pre><code>Which declares via the input type that invalid values for `p` are not allowed.  Passing by value may also be reasonable, but it depends on if changes to an object should be visible after the function is complete.

A final consideration is that pointers carry a notion of ownership. Pointers often point to non-stack allocated objects (e.g., allocated using new), and should be deallocated when no longer needed. Lots of comments can be written indicating ownership &#x2014; &quot;Ownership must be passed to this function, it will call `delete`,&quot; etc. Using references or values can reduce such error-prone commenting burden since they convey no notion of ownership. (Another way to address this, smart pointers, will be covered later. The discussion on the semantic differences between passing by reference and by value still applies in that case, however.)
{% endchallenge %}


{% challenge &quot; Question &quot; %}
What happens when passing a derived object as a base object?
```c++
class Base
{
    public:
        virtual ~Base() {}
        virtual void foo() const { std::cout &lt;&lt; &quot;Base&quot; &lt;&lt; std::endl; }
};
class Derived : public Base
{
    public:
        virtual void foo() const { std::cout &lt;&lt; &quot;Derived&quot; &lt;&lt; std::endl; }
};

void bar1(Base b) { b.foo(); }
void bar2(Base&amp; rB) { rB.foo(); }
void bar3(Base* pB) { pB-&gt;foo(); }
...
Derived d;
bar1(d);
bar2(d);
bar3(&amp;d);
</code></pre></div></div><div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(5820750375);" id="-solution-click-to-expand"><i class="fa fa-line-chart"></i>  Solution <span id="heading-5820750375">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-5820750375"><p>All calls do not produce identical output &#x2014; when a derived object is passed by value, only the &apos;base&apos; copy constructor is called. Things that are not copied include the ability to call derived object virtual functions. This is known as the slicing problem. </p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(8644351438);" id="-question-"><i class="fa fa-square-o"></i>  Question <span id="heading-8644351438"></span></h3></div><div class="panel-body" id="panel-8644351438"><p>What are the performance implications of returning large objects by value, reference and pointer?</p>
<pre><code>```c++
</code></pre><p>Foo return_by_value()
{ return Foo(); }
Foo&amp; return_by_reference()
{
    //KLUDGE: We can&apos;t return a reference to an object whose lifetime ends
    // after this function exits. Therefore we declare a local static.
    // There are even kludgier methods for dealing with this, however.
    static Foo s_f;
    s_f = Foo();
    return s_f;
}
Foo* return_by_pointer()
{ return new Foo; }</p>
<pre><code>{% solution &quot; Solution &quot; %}
There are significant differences between return by value, reference and pointer; those differences may be surprising. Return by value was the fastest in my runs (.83 s), return by reference the slowest (1.37 s), and return by pointer in between (.90 s). All three require the construction and destruction of a Foo object. It may be useful to examine the differences:

Return by value: You might think this would be the slowest, arguing that it also requires a copy construction. That would have been true several years ago if optimizations were disabled on this code. In this case, the compiler noticed that the object constructed inside the function was going to be destructed after its values were copied. It was able to give the array of the to-be-destroyed object directly to the Foo object in the calling code [^2].

Return by reference: As written in the exercise, this is the slowest &#x2014; perhaps surprisingly so. Its slowness is due to synchronization required when initializing local static variables. (The synchronization, aside from making high-latency calls, quadruples the number of instructions executed.)

Return by pointer: This is sometimes faster than return by value, sometimes slower &#x2014; but usually around the same speed. This doesn&apos;t require the synchronization of return by reference, but does require a small heap allocation.

The details mentioned here aren&apos;t particularly important. The point of this exercise is that returning a large object by value may be the correct decision; concerns about the speed of returning by value are often unfounded and avoiding it is a case of premature pessimization. 

{% endchallenge %}



{% challenge &quot; Question &quot; %}
What are the correctness concerns of using a local static to return by reference?
    ```c++
Foo&amp; return_by_reference()
{
    //KLUDGE: We can&apos;t return a reference to an object whose lifetime ends
    // after this function exits. Therefore we declare a local static.
    // There are even kludgier methods for dealing with this, however.
    static Foo s_f;
    s_f = Foo();
    return s_f;
}

Foo&amp; f1 = return_by_reference();
Foo&amp; f2 = return_by_reference();
std::cout &lt;&lt; &quot;Are f1 and f2 equal? &quot;
&lt;&lt; std::boolalpha &lt;&lt; (f1 == f2) &lt;&lt; std::endl; //Outputs true
</code></pre><div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(9698002874);" id="-solution-click-to-expand"><i class="fa fa-line-chart"></i>  Solution <span id="heading-9698002874">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-9698002874"><p>If the first entry of f1 and f2 are different when printed, why do they compare equal? Since f1 refers to the same object as f2, f1 and f2 will always compare equal. The point? Local static (non-const) objects shouldn&apos;t be used as a way to avoid return by value. It is both wrong and slow.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(1798130342);" id="-question-"><i class="fa fa-square-o"></i>  Question <span id="heading-1798130342"></span></h3></div><div class="panel-body" id="panel-1798130342"><p>Is there a difference in speed when stateful objects are involved?</p>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> Foo
{
    Foo() : v(<span class="hljs-number">10000</span>) {};
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; return_by_value() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> v; }
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; return_by_reference() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> v; }
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;* return_by_pointer() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> &amp;v; }
    <span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v; 
};
</code></pre>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(5285187735);" id="-solution-click-to-expand"><i class="fa fa-line-chart"></i>  Solution <span id="heading-5285187735">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-5285187735"><p>The timings are very different when returning an existing object. Return by value was 5000x slower than the other methods. In this case, return by value MUST call the copy constructor, while return by reference or pointer needed only return the address.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(3460887678);" id="-question-"><i class="fa fa-square-o"></i>  Question <span id="heading-3460887678"></span></h3></div><div class="panel-body" id="panel-3460887678"><p>How should we decide between return by reference or pointer?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(888957556);" id="-solution-click-to-expand"><i class="fa fa-line-chart"></i>  Solution <span id="heading-888957556">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-888957556"><p>If the object to be returned may not exist, return by pointer is natural, as NULL may serve as a sentinel value. Otherwise, return by reference is usually preferred, as that clearly indicates the object is valid. (Again, we&apos;ll ignore smart pointers and skip a discussion of ownership.)</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(7096258360);" id="-question-"><i class="fa fa-square-o"></i>  Question <span id="heading-7096258360"></span></h3></div><div class="panel-body" id="panel-7096258360"><p>What are the consequences of returning a local polymorphic object by value, reference and pointer?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(2535170165);" id="-solution-click-to-expand"><i class="fa fa-line-chart"></i>  Solution <span id="heading-2535170165">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-2535170165"><p>Returning an object created in a function by value produces incorrect results as described in Q4. Returning by reference may produce correct results, but is more fragile. If a static object is referenced, the issues described in Q6 are present. Others returned *(new Derived()), which will produce correct results and avoid the slowness of the static object; however, the complexity of ensuring that referenced object is destructed correctly is still reason enough to avoid it. Return by pointer should be preferred in this case.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(9419745897);" id="-question-"><i class="fa fa-square-o"></i>  Question <span id="heading-9419745897"></span></h3></div><div class="panel-body" id="panel-9419745897"><p>When should we pass by value, reference and pointer?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(3033610118);" id="-solution-click-to-expand"><i class="fa fa-line-chart"></i>  Solution <span id="heading-3033610118">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-3033610118"><p>Pass small objects    by value: Yes, if not polymorphic and changes inside the function should not be present outside the function
Pass small objects by reference: Yes, if no need for a sentinel value
Pass small objects by pointer: Yes, if a sentinel value is needed</p>
<p>Pass large objects by value: Only if the function actually needs a separate copy of the object
Pass large objects by reference: Yes, if no need for a sentinel value
Pass large objects by pointer: Yes, if a sentinel value is needed</p>
<p>Pass polymorphic objects by value: No
Pass polymorphic objects by reference: Yes, if no need for a sentinel value
Pass polymorphic objects by pointer: Yes, if a sentinel value is needed</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(688859126);" id="-question-"><i class="fa fa-square-o"></i>  Question <span id="heading-688859126"></span></h3></div><div class="panel-body" id="panel-688859126"><p>When should we return by value, reference and pointer?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(5364764097);" id="-solution-click-to-expand"><i class="fa fa-line-chart"></i>  Solution <span id="heading-5364764097">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-5364764097"><p>Return small objects by value: Yes, if not polymorphic
Return small objects by reference: Only if the returned object&apos;s will exist after the function is exited 
Return small objects by pointer: Yes, if a sentinel value is needed or the object cannot be on the stack </p>
<p>Return large objects by value: Yes, unless the object&apos;s lifetime exceeds the function call, or measurements show that this impacts performance
Return large objects by reference Yes, if no need for a sentinel value and the object&apos;s lifetime exceeds the function call.
Return large objects by pointer: Yes, if a sentinel value is needed and the object&apos;s lifetime exceeds the function call</p>
<p>Return polymorphic objects by value: No
Return polymorphic objects by reference: Yes, if no need for a sentinel value and object lifetime exceeds function scope
Return polymorphic objects by pointer: Yes, if a sentinel value is needed or return by reference is otherwise inappropriate</p>
</div></div></div></div></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="intro.html" class="navigation navigation-prev " aria-label="Previous page: Pointers, the absolute basics">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="smartp.md" class="navigation navigation-next " aria-label="Next page: Smart pointers">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"A quick refresher","level":"1.4.2","depth":2,"next":{"title":"Smart pointers","level":"1.4.3","depth":2,"path":"analysis/newf2/smartp.md","ref":"analysis/newf2/smartp.md","articles":[]},"previous":{"title":"Pointers, the absolute basics","level":"1.4.1","depth":2,"path":"analysis/newf2/intro.md","ref":"analysis/newf2/intro.md","articles":[]},"dir":"ltr"},"config":{"plugins":["katex","panels@git+https://github.com/lhcb/gitbook-plugin-panels.git#117012fdc18c96831cb88196980c0ea73b0c87b8","collapsible-menu","block-align"],"styles":{"website":"css/website.css"},"pluginsConfig":{"collapsible-menu":{},"block-align":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"panels":{},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"PEP root6 workshop","gitbook":"*","description":"PEP root6 introduction material"},"file":{"path":"analysis/newf2/introexer.md","mtime":"2018-10-16T08:20:09.409Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-10-16T08:45:24.459Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-panels/panels.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-collapsible-menu/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

