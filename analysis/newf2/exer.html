
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Exercises Â· PEP root6 workshop</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-panels/panels.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-block-align/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../../css/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../parallellism.html" />
    
    
    <link rel="prev" href="smartp.md" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../introduction.html">
            
                <a href="../introduction.html">
            
                    
                    Part 1 - Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../feat1.html">
            
                <a href="../feat1.html">
            
                    
                    Part 2 - New C++ features 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="feat2.html">
            
                <a href="feat2.html">
            
                    
                    Part 3 - Smart (and dumb) pointers
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="intro.html">
            
                <a href="intro.html">
            
                    
                    Pointers, the absolute basics
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="introexer.html">
            
                <a href="introexer.html">
            
                    
                    A quick refresher
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="smartp.md">
            
                <span>
            
                    
                    Smart pointers
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4.4" data-path="exer.html">
            
                <a href="exer.html">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../parallellism.html">
            
                <a href="../parallellism.html">
            
                    
                    Part 4 - Parallellism
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../parallell/intro.html">
            
                <a href="../parallell/intro.html">
            
                    
                    Threads and processes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../parallell/example.html">
            
                <a href="../parallell/example.html">
            
                    
                    Posix multithreading
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../parallell/caveats.html">
            
                <a href="../parallell/caveats.html">
            
                    
                    What can go wrong?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../parallell/root.html">
            
                <a href="../parallell/root.html">
            
                    
                    Parallellism with ROOT
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../changes.html">
            
                <a href="../changes.html">
            
                    
                    Part 5 - Changes to user code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../vectorization.html">
            
                <a href="../vectorization.html">
            
                    
                    Part 6 - Vectorization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../declarative.html">
            
                <a href="../declarative.html">
            
                    
                    Part 7 - Declarative analysis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../python/">
            
                <a href="../python/">
            
                    
                    Part 8 - Python
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../python/running.html">
            
                <a href="../python/running.html">
            
                    
                    Running
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../python/operators.html">
            
                <a href="../python/operators.html">
            
                    
                    Objects and operators
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../python/numbers.html">
            
                <a href="../python/numbers.html">
            
                    
                    Numbers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="../python/strings.html">
            
                <a href="../python/strings.html">
            
                    
                    Strings
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="../python/lists.html">
            
                <a href="../python/lists.html">
            
                    
                    Lists and looping
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="../python/dictionaries.html">
            
                <a href="../python/dictionaries.html">
            
                    
                    Dictionaries
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.7" data-path="../python/conditions.html">
            
                <a href="../python/conditions.html">
            
                    
                    Conditions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.8" data-path="../python/methods.html">
            
                <a href="../python/methods.html">
            
                    
                    Methods
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.9" data-path="../python/scripting.html">
            
                <a href="../python/scripting.html">
            
                    
                    Scripting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.10" data-path="../python/modules.html">
            
                <a href="../python/modules.html">
            
                    
                    Modules
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.11" data-path="../python/learning.html">
            
                <a href="../python/learning.html">
            
                    
                    Learning more
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.12" data-path="../python/first_histogram.html">
            
                <a href="../python/first_histogram.html">
            
                    
                    Making your first histogram
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.13" data-path="../python/further_reading.html">
            
                <a href="../python/further_reading.html">
            
                    
                    Further reading
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../bestprac/best_prac.html">
            
                <a href="../bestprac/best_prac.html">
            
                    
                    Part 9 - Best Practices
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="../bestprac/preparing.html">
            
                <a href="../bestprac/preparing.html">
            
                    
                    Preparing your code for debugging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="../bestprac/general.html">
            
                <a href="../bestprac/general.html">
            
                    
                    Some general programming tips
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="../bestprac/crash.html">
            
                <a href="../bestprac/crash.html">
            
                    
                    Where does my code crash
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="../bestprac/memory.html">
            
                <a href="../bestprac/memory.html">
            
                    
                    Finding memory leaks
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Exercises</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h4 id="exercise">Exercise</h4>
<p>Smart Pointers allow you to access the underlying pointer, but they don&apos;t make you do it very often.  However, it&apos;s common for those recently acquainted with smart pointers to ignore the overloaded operators out of either ignorance or a misplaced fear of performance degradation.  Change the following code using <code>.get()</code> to have a more natural syntax:</p>
<pre><code class="lang-c++">  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Bar&gt; pBar(<span class="hljs-keyword">new</span> Bar);

  foo(*(pBar.get()));

  pBar.get()-&gt;x();

  <span class="hljs-keyword">if</span>(pBar.get())
  {
    <span class="hljs-comment">//Do some stuff...</span>
  }
</code></pre>
<p>Becomes:</p>
<pre><code class="lang-diff">   std::unique_ptr&lt;Bar&gt; pBar(new Bar);
<span class="hljs-deletion">-  foo(*(pBar.get()));</span>
<span class="hljs-addition">+  foo(*pBar);</span>
<span class="hljs-deletion">-  pBar.get()-&gt;x();</span>
<span class="hljs-addition">+  pBar-&gt;x();</span>
<span class="hljs-deletion">-  if(pBar.get())</span>
<span class="hljs-addition">+  if(pBar)</span>
   {
     //Do some stuff...
   }
</code></pre>
<h4 id="question-1">Question 1:</h4>
<p>When should <code>.get()</code> be used on a smart pointer?</p>
<h4 id="answer-1">Answer 1:</h4>
<p>Usually when code outside your control requires a raw pointer -- but not ownership of the pointer.  Herb Sutter has also argued that in modern code, a raw pointer may indicate that the caller should do nothing with ownership (i.e., don&apos;t delete it).  Our codebase probably isn&apos;t modern enough to allow this -- too many instances of raw pointers still conveying ownership..</p>
<h4 id="question-2">Question 2:</h4>
<p><code>unique_ptr::release</code> has a similar signature to <code>unique_ptr::get</code>.  How is it different?</p>
<h4 id="answer-2">Answer 2:</h4>
<p>That should be called when passing ownership of the pointer elsewhere.  For example, the GUI toolkit wxWidgets expects heap-allocated<sup><a href="#fn_0" id="reffn_0">0</a></sup> objects which it will delete once it&apos;s done using them.  <code>release</code> on <code>unique_ptr</code> means that <code>unique_ptr</code> will no longer hold that pointer, nor attempt to delete it -- otherwise it wouldn&apos;t be unique.  See the next training for gotchas when releasing <code>unique_ptr</code>s.</p>
<h4 id="question-3">Question 3:</h4>
<p>It would be possible to allow the following code to compile.  What could happen if <code>shared_ptr</code> or <code>unique_ptr</code> were changed to allow it?</p>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*)</span> </span>{}

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; pInt(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">5</span>));
foo1(pInt);
</code></pre>
<h4 id="answer-3">Answer 3:</h4>
<p>Firstly, calling <code>foo1</code> as shown will fail, since you can&apos;t implicitly convert <code>shared_ptr&lt;T&gt;</code> to <code>T*</code>.  If such a conversion were added, <code>foo1(pInt)</code> would compile &amp; work, but <code>delete pInt;</code> would merely compile -- <code>delete</code> would be called twice on that pointer.  (It would probably work until your software was unserviceable -- e.g., deployed on a satellite.  This is in keeping with software&apos;s reputation for being spiteful.)  Accidentally calling <code>delete</code> as shown could happen if you were trying to replace raw pointers with smart pointers in legacy code.</p>
<h4 id="question-4">Question 4:</h4>
<p>It would be possible to allow the following code to compile.  What could happen if <code>shared_ptr</code> or <code>unique_ptr</code> were changed to allow it?</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; pInt2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">5</span>);
</code></pre>
<h4 id="answer-4">Answer 4:</h4>
<p>The previous code would require <code>unique_ptr&lt;T&gt;</code> to be implicitly constructable from T*.  Suppose you had legacy code like this:</p>
<pre><code class="lang-c++">foo2(<span class="hljs-keyword">int</span>* pInt)
{...}

...

<span class="hljs-keyword">int</span>* pMyInt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>);
foo2(pMyInt);
*pMyInt = <span class="hljs-number">43</span>;
</code></pre>
<p>Then, using shiny new smart_ptrs, you changed part, but didn&apos;t see the later code:</p>
<pre><code class="lang-c++">foo2(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; pInt)
{...}

...

<span class="hljs-keyword">int</span>* pMyInt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>);
foo2(pMyInt);
*pMyInt = <span class="hljs-number">43</span>; <span class="hljs-comment">//Earth-shattering kaboom!</span>
</code></pre>
<p>As designed, the compiler will produce an error in the second case.  It&apos;s still possible to have exactly these problems, but you need to go out of your way to get them.  Code should be written to protect against Murphy (accidental misuse), not Machiavelli (deliberate attempts to misuse) <sup><a href="#fn_1" id="reffn_1">1</a></sup>.  (This is not speaking in reference to sanitizing user input, which you should usually assume to be dangerous.)</p>
<hr>
<h4 id="question-5">Question 5:</h4>
<p>The following contains a mistake.  Fix it, and explain why it was wrong.</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p1(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>));
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p2(p1.get());
</code></pre>
<h4 id="answer-5">Answer 5:</h4>
<p><code>p1</code> and <code>p2</code> will both attempt to delete the same pointer, without knowing the other exists.  A <code>shared_ptr</code> counts the number of pointers referencing the same pointer and deallocates that pointer once no one is referencing it.  With code like the previous, we get the following:</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p1(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>));<span class="hljs-comment">//p1 references the new pointer, reference count = 1</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p2(p1.get());<span class="hljs-comment">//p2 thinks it&apos;s the only guy looking at the pointer, reference count = 1</span>
<span class="hljs-comment">//(automatically called) p2.~shared_ptr&lt;int&gt;() -- deletes the pointer in p2</span>
<span class="hljs-comment">//(automatically called) p1.~shared_ptr&lt;int&gt;() -- Oops, p1&apos;s pointer was already deleted!</span>
</code></pre>
<p>The correct way to ensure the reference counts are correct is to copy the shared_ptr, not just the underlying pointer:</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p1(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>));<span class="hljs-comment">//p1 references the new pointer, reference count = 1</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p2(p1);<span class="hljs-comment">//p2 references p1&apos;s pointer &amp; p1&apos;s reference count, reference count = 2</span>
<span class="hljs-comment">//(automatically called) p2.~shared_ptr&lt;int&gt;() -- decrements the reference count ( = 1 )</span>
<span class="hljs-comment">//(automatically called) p1.~shared_ptr&lt;int&gt;() -- decrements the reference count to zero and deletes the pointer.</span>
</code></pre>
<h4 id="question-6">Question 6:</h4>
<p>The following contains a mistake.  Fix it, and explain why it was wrong.</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p3(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">42</span>]);
</code></pre>
<h4 id="answer-6">Answer 6:</h4>
<p><code>std::unique_ptr&lt;T&gt;</code> will call <code>delete</code> on its pointer -- that means the pointer should be allocated using <code>new</code>.  If we want to use <code>new[N]</code>, we should store it in <code>std::unique_ptr&lt;T[]&gt;</code>, which will correctly call <code>delete[]</code>.  Furthermore, it offers <code>operator[]</code> and disallows <code>operator*</code> &amp; <code>operator-&gt;</code>, which makes it less awkward to index elements after the first.</p>
<h4 id="question-7">Question 7:</h4>
<p>When would you use a <code>unique_ptr</code> versus a <code>shared_ptr</code>?</p>
<h4 id="answer-7">Answer 7:</h4>
<p>Use <code>shared_ptr</code> when you know that ownership of the pointer must be shared in more than one place.  Note that <em>ownership</em> == <em>responsability to deallocate the pointer</em>.
Use <code>unique_ptr</code> when you don&apos;t know that ownership of the pointer must be shared.</p>
<h4 id="question-8">Question 8:</h4>
<p>Suppose you have a class which returns a pointer which the user <em>may</em> wish to store in a <code>shared_ptr</code>.  What type should you return?</p>
<h4 id="answer-8">Answer 8:</h4>
<p>Return a <code>unique_ptr</code> to that type <sup><a href="#fn_2" id="reffn_2">2</a></sup>.  <code>unique_ptr</code>s are convertible to <code>shared_ptr</code>s, so returning a <code>unique_ptr</code> prevents memory leaks without restricting how that pointer is used later.
Returning a raw pointer instead would certainly work, but goes against, e.g., Scott Meyers&apos;s advice to &quot;make interfaces easy to use correctly and hard to use incorrectly.&quot;  (See Item 18 of Effective C++.)</p>
<p>The following code opens a handle to a file using the C-style <code>FILE*</code> interface
and closes the handle before returning.</p>
<pre><code class="lang-c++">
  FILE* pFin = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">try</span>
  {
    <span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">filename</span><span class="hljs-params">(<span class="hljs-string">&quot;c:\\Windows\\win.ini&quot;</span>)</span></span>;
    pFin = <span class="hljs-built_in">std</span>::fopen(filename.c_str(), <span class="hljs-string">&quot;r&quot;</span>);
    <span class="hljs-keyword">if</span> (!pFin)
      <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">char</span> data[<span class="hljs-number">10</span>];
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::fread(data, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, pFin) &lt;= <span class="hljs-number">0</span>)
    {
      <span class="hljs-built_in">std</span>::fclose(pFin);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-built_in">std</span>::fclose(pFin);
  }
  <span class="hljs-keyword">catch</span> (...)
  {
    <span class="hljs-keyword">if</span> (pFin)
      <span class="hljs-built_in">std</span>::fclose(pFin);
    <span class="hljs-keyword">throw</span>;  <span class="hljs-comment">//rethrow after closing file</span>
  }
</code></pre>
<p>We could change it to use
iostreams, but for this exercise, change the code to just use a smart
pointer (<code>std::shared_ptr</code>) to <code>FILE</code> with a custom deleter, so that the
<code>fclose()</code> call doesn&apos;t have to appear in so many places, and eliminate the
try-catch block.</p>
<h4 id="answer">Answer:</h4>
<pre><code class="lang-c++">    <span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">filename</span><span class="hljs-params">(<span class="hljs-string">&quot;c:\\Windows\\win.ini&quot;</span>)</span></span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;FILE&gt; pFin(<span class="hljs-built_in">std</span>::fopen(filename.c_str(), <span class="hljs-string">&quot;r&quot;</span>), &amp;<span class="hljs-built_in">std</span>::fclose);
    <span class="hljs-keyword">if</span> (!pFin)
      <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">char</span> data[<span class="hljs-number">10</span>];
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::fread(data, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, pFin.get()) &lt;= <span class="hljs-number">0</span>)
    {
      <span class="hljs-keyword">return</span>;
    }
</code></pre>
<p>Notice that not only do the <code>fclose()</code> calls go away, but also the try/catch block goes away, since there&apos;s no longer a need to call <code>fclose()</code> and then re-throw.</p>
<hr>
<h4 id="question">Question:</h4>
<p>What could you do if your deleter had a declaration that didn&apos;t match the 
<code>void(T*)</code> interface that the smart pointers expect?</p>
<h4 id="answer">Answer:</h4>
<p>Use the adapter pattern to wrap the deleter with the appropriate interface.  One easy way is to wrap it in a lambda which does match that declaration.</p>
<hr>
<h4 id="bonus-question">Bonus Question:</h4>
<p>How would you manage a resource that uses an int-type handle instead of a
pointer? Could a smart pointer still do the job, and if so, how?</p>
<h4 id="answer">Answer:</h4>
<p>Depending on how frequently that resource was used, you may wish to create
a RAII-type class to store it.  If it&apos;s infrequently used, you could use
a smart pointer.  For example:</p>
<pre><code class="lang-c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> HANDLE;<span class="hljs-comment">//Like a Windows API identifier.</span>
<span class="hljs-function">HANDLE <span class="hljs-title">allocate_mutex</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-comment">/*OS-stuff here*/</span> <span class="hljs-keyword">static_cast</span>&lt;HANDLE&gt;(<span class="hljs-built_in">std</span>::rand()); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate_mutex</span><span class="hljs-params">(HANDLE)</span> </span>{<span class="hljs-comment">/*OS-stuff here*/</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Called!&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; }

<span class="hljs-keyword">struct</span> mutex_destructor
{
  <span class="hljs-keyword">typedef</span> HANDLE pointer;<span class="hljs-comment">//Just store an int, not a pointer.</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(HANDLE val)</span>
  </span>{ deallocate_mutex(val); }
};
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">example</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;HANDLE, mutex_destructor&gt; mutex(allocate_mutex());
  <span class="hljs-comment">//Note that the unique_ptr size is unchanged, since mutex_destructor has no state.</span>
  assert(<span class="hljs-keyword">sizeof</span>(HANDLE) == <span class="hljs-keyword">sizeof</span>(mutex));
}
</code></pre>
<hr>
<h4 id="exercise">Exercise:</h4>
<p>Using custom deleters with <code>std::unique_ptr</code> is a little more complicated
 than for <code>std::shared_ptr</code>, because the deleter becomes part of its type
 (the 2nd template argument). Try rewriting the above example to use
 <code>std::unique_ptr</code> instead of <code>std::shared_ptr</code>.</p>
<h4 id="answer">Answer:</h4>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">example1unique</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">filename</span><span class="hljs-params">(<span class="hljs-string">&quot;c:\\Windows\\win.ini&quot;</span>)</span></span>;
  <span class="hljs-keyword">auto</span> deleter = [](FILE* f){<span class="hljs-built_in">std</span>::fclose(f);};
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;FILE,<span class="hljs-keyword">void</span>(FILE*)&gt; p_fin(<span class="hljs-built_in">std</span>::fopen(filename.c_str(), <span class="hljs-string">&quot;r&quot;</span>),&amp;<span class="hljs-built_in">std</span>::fclose);
  <span class="hljs-keyword">if</span> (!pFin)
    <span class="hljs-keyword">return</span>;

  <span class="hljs-keyword">char</span> data[<span class="hljs-number">10</span>];
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::fread(data, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, pFin.get()) &lt;= <span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span>;
}
</code></pre>
<hr>
<h4 id="bonus-question">Bonus Question:</h4>
<p>Does <code>std::unique_ptr</code>&apos;s size increase when you use a custom deleter?
If so, why?</p>
<h4 id="answer">Answer:</h4>
<p>Sometimes.  If the deleter need not be passed in as a constructor argument,
then the <code>unique_ptr</code> size will be unchanged.  If the deleter must be
referenced or otherwise stored by the <code>unique_ptr</code>, it will increase.</p>
<hr>
<h4 id="question">Question:</h4>
<p>Why is the <code>weak_ptr</code> class designed such that we have to convert the <code>weak_ptr</code>
into a <code>shared_ptr</code> before using the object the weak pointer refers to?</p>
<h4 id="answer">Answer:</h4>
<p>You must obtain a reference to the object to insure that it is not deleted
while the code is accessing it.</p>
<hr>
<h4 id="question">Question:</h4>
<p>Assuming that <code>p_int</code>&apos;s lifetime is managed in a separate thread of execution, what could happen if the code were structured like this:</p>
<pre><code class="lang-c++"><span class="hljs-keyword">if</span> (!p_weak_int.expired())
{
  <span class="hljs-keyword">auto</span> p_tmp_copy = p_weak_int.lock();
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;value = &quot;</span> &lt;&lt; *p_tmp_copy &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
<span class="hljs-keyword">else</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;expired\n&quot;</span>;
</code></pre>
<h4 id="answer">Answer:</h4>
<p>Consider what would happen if instruction interleaving caused the pointer to be deleted
between the call to expired and the call to lock -- the next line would (hopefully) crash!</p>
<hr>
<h4 id="question">Question:</h4>
<p>In the un-threaded example above, a raw pointer would&apos;ve served just as well as a
<code>std::weak_ptr</code>. However, suppose we had 3 threads, each owning one copy
of the <code>std::shared_ptr</code> (so its reference count is 3). Suppose each thread
could terminate at any time (thus decreasing the reference count until it
reaches 0 and the memory is freed). The main thread has a <code>std::weak_ptr</code>
copy and is monitoring/reporting its value periodically.</p>
<p>Now what benefit(s) might using a <code>std::weak_ptr</code> provide over using a copy
of the raw pointer?</p>
<h4 id="answer">Answer:</h4>
<p>If we had a raw pointer we wouldn&apos;t be able to test if it still points to
anything valid (the value of the pointer doesn&apos;t get changed), whereas with 
a <code>weak_ptr</code>, we can test if the pointer is still valid.</p>
<hr>
<h4 id="question">Question:</h4>
<pre><code class="lang-c++"><span class="hljs-keyword">auto</span> p_unique = get_unique_ptr(my_lib.open_handle(),
[&amp;](<span class="hljs-keyword">int</span>* p_handle) { my_lib.close_handle(p_handle); });

<span class="hljs-comment">//Now suppose we need to change to a shared_ptr:</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p_shared(p_unique.release());
</code></pre>
<p>What&apos;s wrong with the conversion to <code>shared_ptr</code> and why does it cause a
crash?</p>
<h4 id="answer">Answer:</h4>
<p>The custom deleter is not transferred from the <code>unique_ptr</code> to the <code>shared_ptr</code> when you use <code>release()</code>.  Therefore, when the <code>shared_ptr</code> goes out of scope, it calls delete on the raw pointer instead of the custom deleter.</p>
<hr>
<h4 id="question">Question:</h4>
<p>The fix for the above looks like this:</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p_shared(<span class="hljs-built_in">std</span>::move(p_unique));
</code></pre>
<p>Rewrite the code above. Why do you have to use <code>std::move()</code>?</p>
<h4 id="answer">Answer:</h4>
<p><code>unique_ptr</code> cannot be copied, as that would not provide unique ownership
of the pointer.  <code>unique_ptr</code> can be moved from.  This allows <code>unique_ptr</code> to
be returned from functions, used in std containers, and more.  <code>std::move</code>
explicitly moves the pointer out of <code>p_unique</code> into <code>p_shared</code>.</p>
<hr>
<h4 id="question">Question:</h4>
<p>When we copied a <code>shared_ptr</code> to another <code>shared_ptr</code>, we didn&apos;t have to use
<code>std::move()</code>. Why not?</p>
<h4 id="answer">Answer:</h4>
<p>Because <code>shared_ptrs</code> are copy assignable whereas <code>unique_ptr</code>s are not.  With
a <code>unique_ptr</code>, we have to help transfer ownership through the move because
ownership can not be copied.</p>
<p>It seems that explicitly calling <code>std::move</code> is usually only necessary when
writing move constructors and move assignment operators.  (There are other
cases, like when writing algorithms, but moves are usually safest
(and fastest!) when implicitly generated.)</p>
<hr>
<h4 id="question">Question:</h4>
<pre><code class="lang-c++"><span class="hljs-comment">//We have a unique_ptr to const and we want to switch to a unique_ptr to</span>
<span class="hljs-comment">// non-const:</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&gt; p_const_unique(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">5</span>));
<span class="hljs-comment">//std::unique_ptr&lt;int&gt; p_my_non_const_int(std::move(p_const_unique));</span>
</code></pre>
<p>If you uncomment the line above, it won&apos;t compile.  Why not?</p>
<h4 id="answer">Answer:</h4>
<p>Just as with raw pointers, converting a pointer to <code>const</code> to a pointer to
non-<code>const</code> will fail.</p>
<p>From a higher-level point of view, if this conversion were allowed, 
then the following could happen.</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&gt; p_const_unique(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">5</span>));
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p_my_non_const_int(<span class="hljs-built_in">std</span>::move(p_const_unique));
<span class="hljs-comment">// We are changing the value of something originally declared const!</span>
*p_my_non_const_int = <span class="hljs-number">4</span>;
</code></pre>
<hr>
<h4 id="question">Question:</h4>
<pre><code class="lang-c++"><span class="hljs-comment">//We have a shared_ptr and we want to convert it to a unique_ptr:</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p_shared_int(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">6</span>));
<span class="hljs-comment">//std::unique_ptr&lt;int&gt; p_unique_int(std::move(p_shared_int));</span>
</code></pre>
<p>If you uncomment the line above, it won&apos;t compile. Why not?
You can create a <code>shared_ptr</code> from a <code>unique_ptr</code>, so why can&apos;t you create a
<code>unique_ptr</code> from a <code>shared_ptr</code>?</p>
<h4 id="answer">Answer:</h4>
<p>Simple answer: It would require that all others who have a shared_ptr to a
resource to give it up, which isn&apos;t realistically possible in C++.
Less-simple answer: While <code>shared_ptr</code> has a <code>unique</code> member function which indicates if more than one copy of it exists, it seems the committee didn&apos;t find once-shared-but-now-unique a common enough use-case to merit a conversion.  Since you can check uniqueness at runtime, nothing stops you from acting as if the <code>shared_ptr</code> were a <code>unique_ptr</code> once you&apos;ve checked.</p>
<h4 id="question-1">Question 1:</h4>
<p>Consider the following code:</p>
<pre><code class="lang-c++">boost::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; int1(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>));
</code></pre>
<p>How many allocations were required?  What was the size of each allocation?</p>
<h4 id="answer-1">Answer 1:</h4>
<p>For 32-bit VC10, two allocations were required, 4 bytes for the first, 16 bytes for the second.
For 64-bit VC10, two allocations were required, 4 bytes for the first, 24 bytes for the second.
There are two allocations for a single <code>shared_ptr</code>, one for the data being pointed to (what&apos;s returned by <code>std::shared_ptr::get</code>) and one for the reference count (so co-owning shared pointers know where to look to see how many other referrers there are).</p>
<hr>
<h4 id="exercise">Exercise:</h4>
<p>Create a int2 <code>shared_ptr</code> using <code>make_shared</code>.</p>
<pre><code class="lang-c++"><span class="hljs-keyword">auto</span> int2 = <span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);
</code></pre>
<hr>
<h4 id="question-2">Question 2:</h4>
<p>How many allocations were required?  What was the size of each allocation?</p>
<h4 id="answer-2">Answer 2:</h4>
<p><code>make_shared</code> allocates the object pointed to and the reference count at the same time.  Essentially, it creates one <code>struct</code> which holds both pieces of data.  Thus:</p>
<p>For 32-bit VC10, one 16-byte allocation was required.
For 64-bit VC10, one 24-byte allocation was required.
If you used any other standard library, you probably got one 24-byte allocation (on 32-bit systems) or one 32-byte allocation (on 64-bit systems). Why are none of the sizes equal to the sum of the individual allocations?  See below.</p>
<hr>
<h4 id="bonus-question-3">BONUS Question 3:</h4>
<p>Be assured that <code>make_shared</code> is allocating enough space for the same items allocated for int1.  There should be something somewhat surprising about the sum of bytes allocated with <code>make_shared</code> versus the original version.  Explain why the surprising result is okay.</p>
<h4 id="bonus-answer-3">BONUS Answer 3:</h4>
<p>This was a harder question than I intended.  First, if you&apos;re using standard library from anyone but Microsoft, you probably noticed that it allocated MORE than the sum of the individual allocations.  This is due to how platforms pad their structs -- it&apos;s more efficient on most platforms to load aligned data.  (In fact, some platforms crash unless this is the case!)  Without delving into excessive detail, rather than allocating 20 bytes for a single struct holding the pointer and the reference count, the compiler allocates 24, so that the next struct is also aligned.</p>
<p>If that&apos;s true, then why does the MS version do what it does?  The STL maintainer uses what he calls the <a href="http://boost.2283326.n4.nabble.com/Smart-Ptr-make-shared-slower-than-shared-ptr-new-on-VC-9-and-10-with-fix-td4587958.html" target="_blank">&quot;we know where you live optimization&quot;</a>.  See his presentation for details, but he essentially saves allocating a pointer by knowing that the allocated pointer was created via <code>make_shared</code>.  This allows the <code>make_shared</code> struct to be one pointer smaller, which in turn allows the struct to be more compact, all without hurting alignment.</p>
<hr>
<h4 id="question-4">Question 4:</h4>
<p>Consider the following code:</p>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">&quot;Normally conditional&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>; }

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span> val)</span>
</span>{}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">example2</span><span class="hljs-params">()</span>
</span>{
  bar(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>)), foo());
}
</code></pre>
<p>Why could calling example2 result in a memory leak?</p>
<h4 id="answer-4">Answer 4:</h4>
<p>C++ arguments may be evaluated in unspecified order.  In the previous, the <code>shared_ptr</code> constructor and <code>foo()</code> must both be evaluated before <code>bar</code> is called, but there is no requirement that the <code>shared_ptr</code> constructor be called before <code>foo()</code> is evaluated.  Thus the order of operations could be:
<code>new int(42)</code>
<code>foo()</code>
and the <code>shared_ptr</code> constructor might never be called, as <code>foo()</code> threw and exception.</p>
<p>This is <a href="http://www.boost.org/doc/libs/1_54_0/libs/smart_ptr/shared_ptr.htm#BestPractices" target="_blank">explicitly warned about</a> in the <code>shared_ptr</code> docs.  So two solutions are:</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">int</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>)); <span class="hljs-comment">//Less freedom to reorder statements.</span>
bar(<span class="hljs-keyword">int</span>, foo());
</code></pre>
<p>or</p>
<pre><code class="lang-c++">bar(<span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>), foo());<span class="hljs-comment">//No problems, make_shared won&apos;t be split to call foo().</span>
</code></pre>
<hr>
<h4 id="question-5">Question 5:</h4>
<p><code>std::make_shared</code> always uses the <code>std::allocator</code> to retrieve memory.  What should we use if we have a different allocator?</p>
<h4 id="answer-5">Answer 5:</h4>
<p><a href="http://www.boost.org/doc/libs/1_54_0/libs/smart_ptr/make_shared.html#functions" target="_blank">std::allocate_shared</a></p>
<hr>
<h4 id="question-6">Question 6:</h4>
<p>Consider the following two ways to allocate an array:</p>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">example3</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">int</span>* int1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">42</span>];
  <span class="hljs-keyword">delete</span> [] int1;

  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; int2(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">42</span>], [](<span class="hljs-keyword">int</span>* p) { <span class="hljs-keyword">delete</span> [] p; });
}
</code></pre>
<p>Both have drawbacks.  Using <code>boost::shared_ptr</code> as of 1.53 you can write:</p>
<pre><code class="lang-c++">boost::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>[]&gt; int3(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">42</span>]);
</code></pre>
<p>or</p>
<pre><code class="lang-c++"><span class="hljs-keyword">auto</span> int4 = boost::make_shared&lt;<span class="hljs-keyword">int</span>[]&gt;(<span class="hljs-number">42</span>);<span class="hljs-comment">//make_shared_noinit is actually functionally equivalent. . .</span>
</code></pre>
<p>The drawbacks to the code for int1 in example3 are obvious, since RAII classes protect against memory leaks.  int2 has drawbacks that aren&apos;t quite as obvious.  Name at least one drawback to storing an array in a <code>shared_ptr</code>.</p>
<h4 id="answer-6">Answer 6:</h4>
<p>Drawback #1: How do you access the second element of the array?  <code>int2[1]</code> doesn&apos;t compile, as there&apos;s no overloaded <code>operator[]</code>.  You end up having to write something like <code>int2.get()[1]</code>, which is probably why languages without pointers are so popular these days.  On the flip side, it can be argued that being able to access <code>*</code> and <code>-&gt;</code> can lead to issues for arrays -- it might be better to require <code>[0]</code> instead.</p>
<p>Drawback #2: 
The code for specifying an array deleter is verbose.  It can be slightly prettier if you write <code>std::default_delete&lt;int[]&gt;</code>, but it&apos;s long enough to be a pain to type much.</p>
<p>Drawback #3 (subtle):
Consider the following code</p>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> B {};
<span class="hljs-keyword">struct</span> D : <span class="hljs-keyword">public</span> B { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>,2&gt; vals };

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;B&gt; p_B(<span class="hljs-keyword">new</span> D);<span class="hljs-comment">//Okay. . .</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;B&gt; bs(<span class="hljs-keyword">new</span> D[<span class="hljs-number">24</span>]);<span class="hljs-comment">//Awful!</span>
</code></pre>
<p>If you&apos;re not seeing what&apos;s wrong immediately, that&apos;s because it&apos;s subtle.  In More Effective C++, Scott Meyers goes farther than his normal counsel to &quot;avoid&quot; things.  He states &quot;never treat arrays polymorphically.&quot; <sup><a href="#fn_1" id="reffn_1">1</a></sup>  And he&apos;s right!  Moving from one element to the next in an array requires pointer arithmetic.  If each element is actually further apart than <code>sizeof(B)</code>, then the pointer arithmetic will be wrong, and you won&apos;t access D[1] when you write pB[1].</p>
<p>Happily, with the new <code>boost::shared_ptr</code> type <sup><a href="#fn_2" id="reffn_2">2</a></sup> code like that above will fail to compile:</p>
<pre><code class="lang-c++">boost::<span class="hljs-built_in">shared_ptr</span>&lt;B[]&gt; bs(<span class="hljs-keyword">new</span> D[<span class="hljs-number">24</span>]);<span class="hljs-comment">//Compile error!</span>
</code></pre>
<p>while allowing other, safe conversions to take place:</p>
<pre><code class="lang-c++">boost::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">const</span> B[]&gt; bs(<span class="hljs-keyword">new</span> B[<span class="hljs-number">24</span>]);<span class="hljs-comment">//non-const to const okay. . .</span>
</code></pre>
<p>Using smart pointers can dramatically improve the safety of your code.  It allows you to convey ownership semantics using something more than comments, while preventing memory leaks and potential double-deletions that come from improper memory leak fixes.</p>
<hr>
<h4 id="notes">Notes:</h4>
<p><sup><a href="#fn_1" id="reffn_1">1</a></sup> See More Effective C++ item 3</p>
<p><sup><a href="#fn_2" id="reffn_2">2</a></sup> <a href="http://www.boost.org/doc/libs/1_55_0/libs/smart_ptr/shared_ptr.htm" target="_blank">http://www.boost.org/doc/libs/1_55_0/libs/smart_ptr/shared_ptr.htm</a></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="smartp.md" class="navigation navigation-prev " aria-label="Previous page: Smart pointers">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../parallellism.html" class="navigation navigation-next " aria-label="Next page: Part 4 - Parallellism">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Exercises","level":"1.4.4","depth":2,"next":{"title":"Part 4 - Parallellism","level":"1.5","depth":1,"path":"analysis/parallellism.md","ref":"analysis/parallellism.md","articles":[{"title":"Threads and processes","level":"1.5.1","depth":2,"path":"analysis/parallell/intro.md","ref":"analysis/parallell/intro.md","articles":[]},{"title":"Posix multithreading","level":"1.5.2","depth":2,"path":"analysis/parallell/example.md","ref":"analysis/parallell/example.md","articles":[]},{"title":"What can go wrong?","level":"1.5.3","depth":2,"path":"analysis/parallell/caveats.md","ref":"analysis/parallell/caveats.md","articles":[]},{"title":"Parallellism with ROOT","level":"1.5.4","depth":2,"path":"analysis/parallell/root.md","ref":"analysis/parallell/root.md","articles":[]}]},"previous":{"title":"Smart pointers","level":"1.4.3","depth":2,"path":"analysis/newf2/smartp.md","ref":"analysis/newf2/smartp.md","articles":[]},"dir":"ltr"},"config":{"plugins":["katex","panels@git+https://github.com/lhcb/gitbook-plugin-panels.git#117012fdc18c96831cb88196980c0ea73b0c87b8","collapsible-menu","block-align"],"styles":{"website":"css/website.css"},"pluginsConfig":{"collapsible-menu":{},"block-align":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"panels":{},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"PEP root6 workshop","gitbook":"*","description":"PEP root6 introduction material"},"file":{"path":"analysis/newf2/exer.md","mtime":"2018-10-15T19:00:27.407Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-10-16T07:59:46.974Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-panels/panels.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-collapsible-menu/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

