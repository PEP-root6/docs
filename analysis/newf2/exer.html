
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Exercises Â· PEP root6 workshop</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-panels/panels.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-block-align/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../../css/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../parallellism.html" />
    
    
    <link rel="prev" href="smartp.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../introduction.html">
            
                <a href="../introduction.html">
            
                    
                    Part 1 - Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../feat1.html">
            
                <a href="../feat1.html">
            
                    
                    Part 2 - New C++ features 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../feat2.html">
            
                <a href="../feat2.html">
            
                    
                    Part 3 - Smart (and dumb) pointers
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="intro.html">
            
                <a href="intro.html">
            
                    
                    Pointers, the absolute basics
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="introexer.html">
            
                <a href="introexer.html">
            
                    
                    A quick refresher
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="smartp.html">
            
                <a href="smartp.html">
            
                    
                    Smart pointers
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4.4" data-path="exer.html">
            
                <a href="exer.html">
            
                    
                    Exercises
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../parallellism.html">
            
                <a href="../parallellism.html">
            
                    
                    Part 4 - Parallellism
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../parallell/intro.html">
            
                <a href="../parallell/intro.html">
            
                    
                    Threads and processes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../parallell/example.html">
            
                <a href="../parallell/example.html">
            
                    
                    Posix multithreading
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../parallell/caveats.html">
            
                <a href="../parallell/caveats.html">
            
                    
                    What can go wrong?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../parallell/root.html">
            
                <a href="../parallell/root.html">
            
                    
                    Parallellism with ROOT
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../changes.html">
            
                <a href="../changes.html">
            
                    
                    Part 5 - 5 to 6: changes to user code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../vectorization.html">
            
                <a href="../vectorization.html">
            
                    
                    Part 6 - Vectorization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../declarative.html">
            
                <a href="../declarative.html">
            
                    
                    Part 7 - Declarative analysis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../python/">
            
                <a href="../python/">
            
                    
                    Part 8 - Python
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../python/running.html">
            
                <a href="../python/running.html">
            
                    
                    Running
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../python/operators.html">
            
                <a href="../python/operators.html">
            
                    
                    Objects and operators
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../python/numbers.html">
            
                <a href="../python/numbers.html">
            
                    
                    Numbers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="../python/strings.html">
            
                <a href="../python/strings.html">
            
                    
                    Strings
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="../python/lists.html">
            
                <a href="../python/lists.html">
            
                    
                    Lists and looping
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="../python/dictionaries.html">
            
                <a href="../python/dictionaries.html">
            
                    
                    Dictionaries
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.7" data-path="../python/conditions.html">
            
                <a href="../python/conditions.html">
            
                    
                    Conditions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.8" data-path="../python/methods.html">
            
                <a href="../python/methods.html">
            
                    
                    Methods
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.9" data-path="../python/scripting.html">
            
                <a href="../python/scripting.html">
            
                    
                    Scripting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.10" data-path="../python/modules.html">
            
                <a href="../python/modules.html">
            
                    
                    Modules
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.11" data-path="../python/learning.html">
            
                <a href="../python/learning.html">
            
                    
                    Learning more
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.12" data-path="../python/pyroot.html">
            
                <a href="../python/pyroot.html">
            
                    
                    PyROOT
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../bestprac/best_prac.html">
            
                <a href="../bestprac/best_prac.html">
            
                    
                    Part 9 - Best Practices
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="../bestprac/preparing.html">
            
                <a href="../bestprac/preparing.html">
            
                    
                    Preparing your code for debugging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="../bestprac/general.html">
            
                <a href="../bestprac/general.html">
            
                    
                    Some general programming tips
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="../bestprac/crash.html">
            
                <a href="../bestprac/crash.html">
            
                    
                    Where does my code crash
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="../bestprac/memory.html">
            
                <a href="../bestprac/memory.html">
            
                    
                    Finding memory leaks
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Exercises</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="exercise">Exercise</h1>
<p>Below is a very long page of exercises related to using smart pointers, varying in difficulty. Click on &apos;solution&apos; to see the answer to the questions. You can put the questions &apos;in action&apos; by writing small C++ programs, but they are also answerable by just inspecting the code snippets.  </p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(6361038979);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-6361038979"></span></h3></div><div class="panel-body" id="panel-6361038979"><p>Smart Pointers allow you to access the underlying pointer, but they don&apos;t make you do it very often.  However, it&apos;s common for those recently acquainted with smart pointers to ignore the overloaded operators out of either ignorance or a misplaced fear of performance degradation.  Change the following code using <code>.get()</code> to have a more natural syntax:</p>
<pre><code class="lang-c++">  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Bar&gt; pBar(<span class="hljs-keyword">new</span> Bar);

  foo(*(pBar.get()));

  pBar.get()-&gt;x();

  <span class="hljs-keyword">if</span>(pBar.get())
  {
    <span class="hljs-comment">//Do some stuff...</span>
  }
</code></pre>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(9683638259);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-9683638259">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-9683638259"><p>Becomes:</p>
<pre><code class="lang-diff">   std::unique_ptr&lt;Bar&gt; pBar(new Bar);
<span class="hljs-deletion">-  foo(*(pBar.get()));</span>
<span class="hljs-addition">+  foo(*pBar);</span>
<span class="hljs-deletion">-  pBar.get()-&gt;x();</span>
<span class="hljs-addition">+  pBar-&gt;x();</span>
<span class="hljs-deletion">-  if(pBar.get())</span>
<span class="hljs-addition">+  if(pBar)</span>
   {
     //Do some stuff...
   }
</code></pre>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(1831715382);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-1831715382"></span></h3></div><div class="panel-body" id="panel-1831715382"><p>When should <code>.get()</code> be used on a smart pointer?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(5738255283);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-5738255283">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-5738255283"><p>Usually when code outside your control requires a raw pointer -- but not ownership of the pointer.  Herb Sutter has also argued that in modern code, a raw pointer may indicate that the caller should do nothing with ownership (i.e., don&apos;t delete it).  Our codebase probably isn&apos;t modern enough to allow this -- too many instances of raw pointers still conveying ownership..</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(5148805226);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-5148805226"></span></h3></div><div class="panel-body" id="panel-5148805226"><p><code>unique_ptr::release</code> has a similar signature to <code>unique_ptr::get</code>.  How is it different?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(4217588338);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-4217588338">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-4217588338"><p>That should be called when passing ownership of the pointer elsewhere.  For example, the GUI toolkit wxWidgets expects heap-allocated[^0] objects which it will delete once it&apos;s done using them.  <code>release</code> on <code>unique_ptr</code> means that <code>unique_ptr</code> will no longer hold that pointer, nor attempt to delete it -- otherwise it wouldn&apos;t be unique.  See the next training for gotchas when releasing <code>unique_ptr</code>s.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(8559155853);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-8559155853"></span></h3></div><div class="panel-body" id="panel-8559155853"><p>It would be possible to allow the following code to compile.  What could happen if <code>shared_ptr</code> or <code>unique_ptr</code> were changed to allow it?</p>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*)</span> </span>{}

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; pInt(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">5</span>));
foo1(pInt);
</code></pre>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(1488223917);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-1488223917">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-1488223917"><p>Firstly, calling <code>foo1</code> as shown will fail, since you can&apos;t implicitly convert <code>shared_ptr&lt;T&gt;</code> to <code>T*</code>.  If such a conversion were added, <code>foo1(pInt)</code> would compile &amp; work, but <code>delete pInt;</code> would merely compile -- <code>delete</code> would be called twice on that pointer.  (It would probably work until your software was unserviceable -- e.g., deployed on a satellite.  This is in keeping with software&apos;s reputation for being spiteful.)  Accidentally calling <code>delete</code> as shown could happen if you were trying to replace raw pointers with smart pointers in legacy code.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(1512627780);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-1512627780"></span></h3></div><div class="panel-body" id="panel-1512627780"><p>It would be possible to allow the following code to compile.  What could happen if <code>shared_ptr</code> or <code>unique_ptr</code> were changed to allow it?</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; pInt2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">5</span>);
</code></pre>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(6909655975);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-6909655975">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-6909655975"><p>The previous code would require <code>unique_ptr&lt;T&gt;</code> to be implicitly constructable from T*.  Suppose you had legacy code like this:</p>
<pre><code class="lang-c++">foo2(<span class="hljs-keyword">int</span>* pInt)
{...}

...

<span class="hljs-keyword">int</span>* pMyInt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>);
foo2(pMyInt);
*pMyInt = <span class="hljs-number">43</span>;
</code></pre>
<p>Then, using shiny new smart_ptrs, you changed part, but didn&apos;t see the later code:</p>
<pre><code class="lang-c++">foo2(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; pInt)
{...}

...

<span class="hljs-keyword">int</span>* pMyInt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>);
foo2(pMyInt);
*pMyInt = <span class="hljs-number">43</span>; <span class="hljs-comment">//Earth-shattering kaboom!</span>
</code></pre>
<p>As designed, the compiler will produce an error in the second case.  It&apos;s still possible to have exactly these problems, but you need to go out of your way to get them.  Code should be written to protect against Murphy (accidental misuse), not Machiavelli (deliberate attempts to misuse) [^1].  (This is not speaking in reference to sanitizing user input, which you should usually assume to be dangerous.)</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(9901006718);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-9901006718"></span></h3></div><div class="panel-body" id="panel-9901006718"><p>The following contains a mistake.  Fix it, and explain why it was wrong.</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p1(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>));
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p2(p1.get());
</code></pre>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(5466400072);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-5466400072">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-5466400072"><p><code>p1</code> and <code>p2</code> will both attempt to delete the same pointer, without knowing the other exists.  A <code>shared_ptr</code> counts the number of pointers referencing the same pointer and deallocates that pointer once no one is referencing it.  With code like the previous, we get the following:</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p1(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>));<span class="hljs-comment">//p1 references the new pointer, reference count = 1</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p2(p1.get());<span class="hljs-comment">//p2 thinks it&apos;s the only guy looking at the pointer, reference count = 1</span>
<span class="hljs-comment">//(automatically called) p2.~shared_ptr&lt;int&gt;() -- deletes the pointer in p2</span>
<span class="hljs-comment">//(automatically called) p1.~shared_ptr&lt;int&gt;() -- Oops, p1&apos;s pointer was already deleted!</span>
</code></pre>
<p>The correct way to ensure the reference counts are correct is to copy the shared_ptr, not just the underlying pointer:</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p1(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>));<span class="hljs-comment">//p1 references the new pointer, reference count = 1</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p2(p1);<span class="hljs-comment">//p2 references p1&apos;s pointer &amp; p1&apos;s reference count, reference count = 2</span>
<span class="hljs-comment">//(automatically called) p2.~shared_ptr&lt;int&gt;() -- decrements the reference count ( = 1 )</span>
<span class="hljs-comment">//(automatically called) p1.~shared_ptr&lt;int&gt;() -- decrements the reference count to zero and deletes the pointer.</span>
</code></pre>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(8378010196);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-8378010196"></span></h3></div><div class="panel-body" id="panel-8378010196"><p>The following contains a mistake.  Fix it, and explain why it was wrong.</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p3(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">42</span>]);
</code></pre>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(283121160);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-283121160">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-283121160"><p><code>std::unique_ptr&lt;T&gt;</code> will call <code>delete</code> on its pointer -- that means the pointer should be allocated using <code>new</code>.  If we want to use <code>new[N]</code>, we should store it in <code>std::unique_ptr&lt;T[]&gt;</code>, which will correctly call <code>delete[]</code>.  Furthermore, it offers <code>operator[]</code> and disallows <code>operator*</code> &amp; <code>operator-&gt;</code>, which makes it less awkward to index elements after the first.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(6063718105);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-6063718105"></span></h3></div><div class="panel-body" id="panel-6063718105"><p>When would you use a <code>unique_ptr</code> versus a <code>shared_ptr</code>?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(9008992503);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-9008992503">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-9008992503"><p>Use <code>shared_ptr</code> when you know that ownership of the pointer must be shared in more than one place.  Note that <em>ownership</em> == <em>responsability to deallocate the pointer</em>.
Use <code>unique_ptr</code> when you don&apos;t know that ownership of the pointer must be shared.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(653702767);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-653702767"></span></h3></div><div class="panel-body" id="panel-653702767"><p>Suppose you have a class which returns a pointer which the user <em>may</em> wish to store in a <code>shared_ptr</code>.  What type should you return?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(2122308964);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-2122308964">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-2122308964"><p>Return a <code>unique_ptr</code> to that type.  <code>unique_ptr</code>s are convertible to <code>shared_ptr</code>s, so returning a <code>unique_ptr</code> prevents memory leaks without restricting how that pointer is used later.
Returning a raw pointer instead would certainly work, but goes against, e.g., Scott Meyers&apos;s advice to &quot;make interfaces easy to use correctly and hard to use incorrectly.&quot;  (See Item 18 of Effective C++.)</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(592324337);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-592324337"></span></h3></div><div class="panel-body" id="panel-592324337"><p>The following code opens a handle to a file using the C-style <code>FILE*</code> interface
and closes the handle before returning.</p>
<pre><code class="lang-c++">
  FILE* pFin = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">try</span>
  {
    <span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">filename</span><span class="hljs-params">(<span class="hljs-string">&quot;c:\\Windows\\win.ini&quot;</span>)</span></span>;
    pFin = <span class="hljs-built_in">std</span>::fopen(filename.c_str(), <span class="hljs-string">&quot;r&quot;</span>);
    <span class="hljs-keyword">if</span> (!pFin)
      <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">char</span> data[<span class="hljs-number">10</span>];
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::fread(data, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, pFin) &lt;= <span class="hljs-number">0</span>)
    {
      <span class="hljs-built_in">std</span>::fclose(pFin);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-built_in">std</span>::fclose(pFin);
  }
  <span class="hljs-keyword">catch</span> (...)
  {
    <span class="hljs-keyword">if</span> (pFin)
      <span class="hljs-built_in">std</span>::fclose(pFin);
    <span class="hljs-keyword">throw</span>;  <span class="hljs-comment">//rethrow after closing file</span>
  }
</code></pre>
<p>We could change it to use
iostreams, but for this exercise, change the code to just use a smart
pointer (<code>std::shared_ptr</code>) to <code>FILE</code> with a custom deleter, so that the
<code>fclose()</code> call doesn&apos;t have to appear in so many places, and eliminate the
try-catch block.</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(7386637922);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-7386637922">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-7386637922"><p>:</p>
<pre><code class="lang-c++">    <span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">filename</span><span class="hljs-params">(<span class="hljs-string">&quot;c:\\Windows\\win.ini&quot;</span>)</span></span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;FILE&gt; pFin(<span class="hljs-built_in">std</span>::fopen(filename.c_str(), <span class="hljs-string">&quot;r&quot;</span>), &amp;<span class="hljs-built_in">std</span>::fclose);
    <span class="hljs-keyword">if</span> (!pFin)
      <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">char</span> data[<span class="hljs-number">10</span>];
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::fread(data, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, pFin.get()) &lt;= <span class="hljs-number">0</span>)
    {
      <span class="hljs-keyword">return</span>;
    }
</code></pre>
<p>Notice that not only do the <code>fclose()</code> calls go away, but also the try/catch block goes away, since there&apos;s no longer a need to call <code>fclose()</code> and then re-throw.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(4874989625);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-4874989625"></span></h3></div><div class="panel-body" id="panel-4874989625"><p>What could you do if your deleter had a declaration that didn&apos;t match the 
<code>void(T*)</code> interface that the smart pointers expect?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(7471729501);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-7471729501">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-7471729501"><p>Use the adapter pattern to wrap the deleter with the appropriate interface.  One easy way is to wrap it in a lambda which does match that declaration.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(6248342531);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-6248342531"></span></h3></div><div class="panel-body" id="panel-6248342531"><p>Why is the <code>weak_ptr</code> class designed such that we have to convert the <code>weak_ptr</code>
into a <code>shared_ptr</code> before using the object the weak pointer refers to?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(977686971);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-977686971">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-977686971"><p>You must obtain a reference to the object to insure that it is not deleted
while the code is accessing it.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(7575253575);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-7575253575"></span></h3></div><div class="panel-body" id="panel-7575253575"><p>Assuming that <code>p_int</code>&apos;s lifetime is managed in a separate thread of execution, what could happen if the code were structured like this:</p>
<pre><code class="lang-c++"><span class="hljs-keyword">if</span> (!p_weak_int.expired())
{
  <span class="hljs-keyword">auto</span> p_tmp_copy = p_weak_int.lock();
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;value = &quot;</span> &lt;&lt; *p_tmp_copy &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
<span class="hljs-keyword">else</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;expired\n&quot;</span>;
</code></pre>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(132571064);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-132571064">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-132571064"><p>Consider what would happen if instruction interleaving caused the pointer to be deleted
between the call to expired and the call to lock -- the next line would (hopefully) crash!</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(6627451906);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-6627451906"></span></h3></div><div class="panel-body" id="panel-6627451906"><p>In the un-threaded example above, a raw pointer would&apos;ve served just as well as a
<code>std::weak_ptr</code>. However, suppose we had 3 threads, each owning one copy
of the <code>std::shared_ptr</code> (so its reference count is 3). Suppose each thread
could terminate at any time (thus decreasing the reference count until it
reaches 0 and the memory is freed). The main thread has a <code>std::weak_ptr</code>
copy and is monitoring/reporting its value periodically.</p>
<p>Now what benefit(s) might using a <code>std::weak_ptr</code> provide over using a copy
of the raw pointer?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(1915327809);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-1915327809">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-1915327809"><p>If we had a raw pointer we wouldn&apos;t be able to test if it still points to
anything valid (the value of the pointer doesn&apos;t get changed), whereas with 
a <code>weak_ptr</code>, we can test if the pointer is still valid.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(1918189053);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-1918189053"></span></h3></div><div class="panel-body" id="panel-1918189053"><pre><code class="lang-c++"><span class="hljs-keyword">auto</span> p_unique = get_unique_ptr(my_lib.open_handle(),
[&amp;](<span class="hljs-keyword">int</span>* p_handle) { my_lib.close_handle(p_handle); });

<span class="hljs-comment">//Now suppose we need to change to a shared_ptr:</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p_shared(p_unique.release());
</code></pre>
<p>What&apos;s wrong with the conversion to <code>shared_ptr</code> and why does it cause a
crash?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(1423494920);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-1423494920">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-1423494920"><p>The custom deleter is not transferred from the <code>unique_ptr</code> to the <code>shared_ptr</code> when you use <code>release()</code>.  Therefore, when the <code>shared_ptr</code> goes out of scope, it calls delete on the raw pointer instead of the custom deleter.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(8930872468);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-8930872468"></span></h3></div><div class="panel-body" id="panel-8930872468"><p>The fix for the above looks like this:</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p_shared(<span class="hljs-built_in">std</span>::move(p_unique));
</code></pre>
<p>Rewrite the code above. Why do you have to use <code>std::move()</code>?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(878712824);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-878712824">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-878712824"><p>:
<code>unique_ptr</code> cannot be copied, as that would not provide unique ownership
of the pointer.  <code>unique_ptr</code> can be moved from.  This allows <code>unique_ptr</code> to
be returned from functions, used in std containers, and more.  <code>std::move</code>
explicitly moves the pointer out of <code>p_unique</code> into <code>p_shared</code>.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(56289510);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-56289510"></span></h3></div><div class="panel-body" id="panel-56289510"><p>When we copied a <code>shared_ptr</code> to another <code>shared_ptr</code>, we didn&apos;t have to use
<code>std::move()</code>. Why not?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(4813480903);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-4813480903">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-4813480903"><p>Because <code>shared_ptrs</code> are copy assignable whereas <code>unique_ptr</code>s are not.  With
a <code>unique_ptr</code>, we have to help transfer ownership through the move because
ownership can not be copied.</p>
<p>It seems that explicitly calling <code>std::move</code> is usually only necessary when
writing move constructors and move assignment operators.  (There are other
cases, like when writing algorithms, but moves are usually safest
(and fastest!) when implicitly generated.)</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(5298348615);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-5298348615"></span></h3></div><div class="panel-body" id="panel-5298348615"><pre><code class="lang-c++"><span class="hljs-comment">//We have a unique_ptr to const and we want to switch to a unique_ptr to</span>
<span class="hljs-comment">// non-const:</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&gt; p_const_unique(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">5</span>));
<span class="hljs-comment">//std::unique_ptr&lt;int&gt; p_my_non_const_int(std::move(p_const_unique));</span>
</code></pre>
<p>If you uncomment the line above, it won&apos;t compile.  Why not?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(416252582);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-416252582">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-416252582"><p>Just as with raw pointers, converting a pointer to <code>const</code> to a pointer to
non-<code>const</code> will fail.</p>
<p>From a higher-level point of view, if this conversion were allowed, 
then the following could happen.</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&gt; p_const_unique(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">5</span>));
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p_my_non_const_int(<span class="hljs-built_in">std</span>::move(p_const_unique));
<span class="hljs-comment">// We are changing the value of something originally declared const!</span>
*p_my_non_const_int = <span class="hljs-number">4</span>;
</code></pre>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(3740016358);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-3740016358"></span></h3></div><div class="panel-body" id="panel-3740016358"><pre><code class="lang-c++"><span class="hljs-comment">//We have a shared_ptr and we want to convert it to a unique_ptr:</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p_shared_int(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">6</span>));
<span class="hljs-comment">//std::unique_ptr&lt;int&gt; p_unique_int(std::move(p_shared_int));</span>
</code></pre>
<p>If you uncomment the line above, it won&apos;t compile. Why not?
You can create a <code>shared_ptr</code> from a <code>unique_ptr</code>, so why can&apos;t you create a
<code>unique_ptr</code> from a <code>shared_ptr</code>?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(2919298426);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-2919298426">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-2919298426"><p>:
Simple answer: It would require that all others who have a shared_ptr to a
resource to give it up, which isn&apos;t realistically possible in C++.
Less-simple answer: While <code>shared_ptr</code> has a <code>unique</code> member function which indicates if more than one copy of it exists, it seems the committee didn&apos;t find once-shared-but-now-unique a common enough use-case to merit a conversion.  Since you can check uniqueness at runtime, nothing stops you from acting as if the <code>shared_ptr</code> were a <code>unique_ptr</code> once you&apos;ve checked.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(2481314319);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-2481314319"></span></h3></div><div class="panel-body" id="panel-2481314319"><p>Consider the following code:</p>
<pre><code class="lang-c++">boost::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; int1(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>));
</code></pre>
<p>How many allocations were required?  What was the size of each allocation?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(9300005466);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-9300005466">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-9300005466"><p>For 32-bit VC10, two allocations were required, 4 bytes for the first, 16 bytes for the second.
For 64-bit VC10, two allocations were required, 4 bytes for the first, 24 bytes for the second.
There are two allocations for a single <code>shared_ptr</code>, one for the data being pointed to (what&apos;s returned by <code>std::shared_ptr::get</code>) and one for the reference count (so co-owning shared pointers know where to look to see how many other referrers there are).</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(4366767710);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-4366767710"></span></h3></div><div class="panel-body" id="panel-4366767710"><p>How many allocations were required?  What was the size of each allocation?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(1290341745);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-1290341745">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-1290341745"><p><code>make_shared</code> allocates the object pointed to and the reference count at the same time.  Essentially, it creates one <code>struct</code> which holds both pieces of data.  Thus:</p>
<p>For 32-bit VC10, one 16-byte allocation was required.
For 64-bit VC10, one 24-byte allocation was required.
If you used any other standard library, you probably got one 24-byte allocation (on 32-bit systems) or one 32-byte allocation (on 64-bit systems). Why are none of the sizes equal to the sum of the individual allocations?  See below.</p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(9190559678);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-9190559678"></span></h3></div><div class="panel-body" id="panel-9190559678"><p>Consider the following code:</p>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">&quot;Normally conditional&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>; }

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span> val)</span>
</span>{}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">example2</span><span class="hljs-params">()</span>
</span>{
  bar(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>)), foo());
}
</code></pre>
<p>Why could calling example2 result in a memory leak?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(830946817);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-830946817">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-830946817"><p>C++ arguments may be evaluated in unspecified order.  In the previous, the <code>shared_ptr</code> constructor and <code>foo()</code> must both be evaluated before <code>bar</code> is called, but there is no requirement that the <code>shared_ptr</code> constructor be called before <code>foo()</code> is evaluated.  Thus the order of operations could be:
<code>new int(42)</code>
<code>foo()</code>
and the <code>shared_ptr</code> constructor might never be called, as <code>foo()</code> threw and exception.</p>
<p>This is <a href="http://www.boost.org/doc/libs/1_54_0/libs/smart_ptr/shared_ptr.htm#BestPractices" target="_blank">explicitly warned about</a> in the <code>shared_ptr</code> docs.  So two solutions are:</p>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">int</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>)); <span class="hljs-comment">//Less freedom to reorder statements.</span>
bar(<span class="hljs-keyword">int</span>, foo());
</code></pre>
<p>or</p>
<pre><code class="lang-c++">bar(<span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>), foo());<span class="hljs-comment">//No problems, make_shared won&apos;t be split to call foo().</span>
</code></pre>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(4336102335);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-4336102335"></span></h3></div><div class="panel-body" id="panel-4336102335"><p><code>std::make_shared</code> always uses the <code>std::allocator</code> to retrieve memory.  What should we use if we have a different allocator?</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(758289303);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-758289303">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-758289303"><p><a href="http://www.boost.org/doc/libs/1_54_0/libs/smart_ptr/make_shared.html#functions" target="_blank">std::allocate_shared</a></p>
</div></div></div></div></p>
<p><div class="panel panel-success"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(6634440391);" id="question"><i class="fa fa-square-o"></i> Question<span id="heading-6634440391"></span></h3></div><div class="panel-body" id="panel-6634440391"><p>Consider the following two ways to allocate an array:</p>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">example3</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">int</span>* int1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">42</span>];
  <span class="hljs-keyword">delete</span> [] int1;

  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; int2(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">42</span>], [](<span class="hljs-keyword">int</span>* p) { <span class="hljs-keyword">delete</span> [] p; });
}
</code></pre>
<p>Both have drawbacks.  Using <code>boost::shared_ptr</code> as of 1.53 you can write:</p>
<pre><code class="lang-c++">boost::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>[]&gt; int3(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">42</span>]);
</code></pre>
<p>or</p>
<pre><code class="lang-c++"><span class="hljs-keyword">auto</span> int4 = boost::make_shared&lt;<span class="hljs-keyword">int</span>[]&gt;(<span class="hljs-number">42</span>);<span class="hljs-comment">//make_shared_noinit is actually functionally equivalent. . .</span>
</code></pre>
<p>The drawbacks to the code for int1 in example3 are obvious, since RAII classes protect against memory leaks.  int2 has drawbacks that aren&apos;t quite as obvious.  Name at least one drawback to storing an array in a <code>shared_ptr</code>.</p>
<div class="panel panel-danger"><div class="panel-heading"><h3 class="panel-title" onclick="javascript:toggle(3461365380);" id="solutionclick-to-expand"><i class="fa fa-line-chart"></i> Solution<span id="heading-3461365380">Click to expand</span></h3></div><div class="panel-body" style="display: none" id="panel-3461365380"><p>Drawback #1: How do you access the second element of the array?  <code>int2[1]</code> doesn&apos;t compile, as there&apos;s no overloaded <code>operator[]</code>.  You end up having to write something like <code>int2.get()[1]</code>, which is probably why languages without pointers are so popular these days.  On the flip side, it can be argued that being able to access <code>*</code> and <code>-&gt;</code> can lead to issues for arrays -- it might be better to require <code>[0]</code> instead.</p>
<p>Drawback #2: 
The code for specifying an array deleter is verbose.  It can be slightly prettier if you write <code>std::default_delete&lt;int[]&gt;</code>, but it&apos;s long enough to be a pain to type much.</p>
<p>Drawback #3 (subtle):
Consider the following code</p>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> B {};
<span class="hljs-keyword">struct</span> D : <span class="hljs-keyword">public</span> B { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>,2&gt; vals };

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;B&gt; p_B(<span class="hljs-keyword">new</span> D);<span class="hljs-comment">//Okay. . .</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;B&gt; bs(<span class="hljs-keyword">new</span> D[<span class="hljs-number">24</span>]);<span class="hljs-comment">//Awful!</span>
</code></pre>
<p>If you&apos;re not seeing what&apos;s wrong immediately, that&apos;s because it&apos;s subtle.  In More Effective C++, Scott Meyers goes farther than his normal counsel to &quot;avoid&quot; things.  He states &quot;never treat arrays polymorphically.&quot;  And he&apos;s right!  Moving from one element to the next in an array requires pointer arithmetic.  If each element is actually further apart than <code>sizeof(B)</code>, then the pointer arithmetic will be wrong, and you won&apos;t access D[1] when you write pB[1].</p>
<p>Happily, with the new <code>boost::shared_ptr</code> type code like that above will fail to compile:</p>
<pre><code class="lang-c++">boost::<span class="hljs-built_in">shared_ptr</span>&lt;B[]&gt; bs(<span class="hljs-keyword">new</span> D[<span class="hljs-number">24</span>]);<span class="hljs-comment">//Compile error!</span>
</code></pre>
<p>while allowing other, safe conversions to take place:</p>
<pre><code class="lang-c++">boost::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">const</span> B[]&gt; bs(<span class="hljs-keyword">new</span> B[<span class="hljs-number">24</span>]);<span class="hljs-comment">//non-const to const okay. . .</span>
</code></pre>
<p>Using smart pointers can dramatically improve the safety of your code.  It allows you to convey ownership semantics using something more than comments, while preventing memory leaks and potential double-deletions that come from improper memory leak fixes.</p>
</div></div></div></div></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="smartp.html" class="navigation navigation-prev " aria-label="Previous page: Smart pointers">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../parallellism.html" class="navigation navigation-next " aria-label="Next page: Part 4 - Parallellism">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Exercises","level":"1.4.4","depth":2,"next":{"title":"Part 4 - Parallellism","level":"1.5","depth":1,"path":"analysis/parallellism.md","ref":"analysis/parallellism.md","articles":[{"title":"Threads and processes","level":"1.5.1","depth":2,"path":"analysis/parallell/intro.md","ref":"analysis/parallell/intro.md","articles":[]},{"title":"Posix multithreading","level":"1.5.2","depth":2,"path":"analysis/parallell/example.md","ref":"analysis/parallell/example.md","articles":[]},{"title":"What can go wrong?","level":"1.5.3","depth":2,"path":"analysis/parallell/caveats.md","ref":"analysis/parallell/caveats.md","articles":[]},{"title":"Parallellism with ROOT","level":"1.5.4","depth":2,"path":"analysis/parallell/root.md","ref":"analysis/parallell/root.md","articles":[]}]},"previous":{"title":"Smart pointers","level":"1.4.3","depth":2,"path":"analysis/newf2/smartp.md","ref":"analysis/newf2/smartp.md","articles":[]},"dir":"ltr"},"config":{"plugins":["katex","panels@git+https://github.com/lhcb/gitbook-plugin-panels.git#117012fdc18c96831cb88196980c0ea73b0c87b8","collapsible-menu","block-align"],"styles":{"website":"css/website.css"},"pluginsConfig":{"collapsible-menu":{},"block-align":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"panels":{},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"PEP root6 workshop","gitbook":"*","description":"PEP root6 introduction material"},"file":{"path":"analysis/newf2/exer.md","mtime":"2018-11-07T16:08:39.410Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-11-07T16:33:05.338Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-panels/panels.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-collapsible-menu/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

